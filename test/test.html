<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<link rel="SHORTCUT ICON" href="../img/default.png">
<title>Perspectives - Test cases</title>

<!-- Include every file so we can verify that all of the objects are testable in meta_test() -->
<script type="text/javascript" src="../extlib/underscore-min.js"></script>
<script type="text/javascript" src="../extlib/spark-md5.min.js"></script>

<script type="text/javascript" src="../about.js"             ></script>
<script type="text/javascript" src="../client_policy.js"     ></script>
<script type="text/javascript" src="../common.js"            ></script>
<script type="text/javascript" src="../generate_svg.js"      ></script>
<script type="text/javascript" src="../notaries.js"          ></script>
<script type="text/javascript" src="../notify.js"            ></script>
<script type="text/javascript" src="../preferences_dialog.js"></script>
<script type="text/javascript" src="../report.js"            ></script>
<script type="text/javascript" src="../results_dialog.js"    ></script>
<script type="text/javascript" src="../statusbar.js"         ></script>
<script type="text/javascript" src="../whitelist_dialog.js"  ></script>
<script type="text/javascript" src="../xml_notary_client.js" ></script>

<!-- Also include every file for testing in browser (no chrome privileges) and fake some functions -->
<script type="text/javascript">
    // if on browser fake objects and make at least some tests work
    if( typeof Components.classes === "undefined") {
        Components.interfaces.nsIWebProgressListener = {
            STATE_IS_BROKEN   : 0,
            STATE_IS_INSECURE : 1,
            STATE_IS_SECURE   : 2
        }
    }
</script>

<script type="text/javascript" src="../plugin/chrome/content/notaries.js"          ></script>
<script type="text/javascript">
    // if on browser fake objects and make at least some tests work
    if( typeof Components.classes === "undefined") {
        Perspectives.strbundle = {
            getString : function(key) {
                return key;
            },
            getFormattedString : function(key, args) {
                return key;
            }
        }

        Perspectives.root_prefs =
          { getIntPref  : function(key) { return Perspectives.root_prefs[key]; }
          , getCharPref : function(key) { return Perspectives.root_prefs[key]; }
          , getBoolPref : function(key) { return Perspectives.root_prefs[key]; }
          , setIntPref  : function(key, value) { Perspectives.root_prefs[key] = value; }
          , setCharPref : function(key, value) { Perspectives.root_prefs[key] = value; }
          , setBoolPref : function(key, value) { Perspectives.root_prefs[key] = value; }
          }
        Perspectives.getNotaryList = function() {
            return [
                {"host": "heimdal.herokuapp.com:80"            , "public_key": "MIHKMA0GCSqGSIb3DQEBAQUAA4G4ADCBtAKBrAGhzbwVcnEaT2Hb9WD9Wvh9CVYu86w+8ZMdO4KG506K77IsERfIuh84YkE4qoDnjfR7TCQBvreVl81lIh5UE0kzO84X673risoBebbGCNjXQNu5mWkq2Qp7SuuemeXaYFmkpc06t2n6NvNcS9JVm8KJRqBKqlwqlFgDuDZPUcYmWoIL4sF9w/3ep9nPSIJYburTdpCaeXPGhMiMzh4E2GnJc3Y2beezGWtciXUCAwEAAQ=="},
               	{"host": "nine-eyes.herokuapp.com:80"          , "public_key": "MIHKMA0GCSqGSIb3DQEBAQUAA4G4ADCBtAKBrAEw+W1dv0a00gzVqvHa8SafHhpYESsCIB8kj4bb1ccXr7u6vaiBN83ssaPi1N/ZNDlyOnqZwopoZGkgzUxMUNzg9P6Vph9l7ldMu8XGuwmFoHBgEys633EPcrJcs46lfvNz5JRrYnjh0WMkj0VXvVlYla2g6aAA80+C7u56D2FodNxWscPNpQWUAHDJOnAWr1CI9CNU/rbl5c85KJ7cW6u+LFBmpXk2xzJ2tq8CAwEAAQ=="},
               	{"host": "perspectives2.networknotary.org:8080", "public_key": "MIHKMA0GCSqGSIb3DQEBAQUAA4G4ADCBtAKBrAHB9gHj3Zyx7u++wTffAsEuRJdjCZSFocs5ZKVamm6O7ywtFCuPgxxYTr3GyrDKj2IBO05iXirOISyX0OtENvs829XjTbKqDgeN1ttDiJmszN939RvBdmzkmXi2zaOXPX3ral56hJOWjOs6NokeBo26ZHux5k9g3AqFer5LNyDVgGrG5q7+INGodDSTYm2W5nvmi55U/pe7MmJCH7EEY1ObGPr17XqZeEbL4ikCAwEAAQ=="},
               	{"host": "perspectives3.networknotary.org:8080", "public_key": "MIHKMA0GCSqGSIb3DQEBAQUAA4G4ADCBtAKBrAFTgU6nDuhi9TDkzypfgaW2ztQbc9eFlVTiLfUkUCmrfn8FqNzxuYdl/Hin3/Usz443GAvOwx0pXocClZ7Xtve06w6HxtuWMxAR0VMhywdzotTJAb/4a2btqHdrUlOZg6l7R66GbCupVWwyDQF7YBKarEGF2v6mRM/WknwaEYVOMu7XDb6zkEf4MsxptQnY7PfNktMMcuhusYjko3IhFmlUl4lue+c3aFR35Y8CAwEAAQ=="},
               	{"host": "perspectives4.networknotary.org:8080", "public_key": "MIHKMA0GCSqGSIb3DQEBAQUAA4G4ADCBtAKBrAFiENC/BwZXOfzDOed4Qbvjd/25MixlCMlRUlfArJAvcjeBRmnY4fdQhi7/VH1qZeTQClegX1FMcuOORD29a4lks12WiXrh1HxLKxCTkPp5ZLqP8OiNxWqHdEQyinh2ulYFXZHWMlXhlsQKV2T7VsmfS0rLeukQAWpgGTXhACyZNpOQgjMm1vWEFaIsd2tT59Son7vxyCcaBoFCWv+zRW6kwaoKi0KgnEHwKwcCAwEAAQ=="},
               	{"host": "perspectives5.networknotary.org:8080", "public_key": "MIHKMA0GCSqGSIb3DQEBAQUAA4G4ADCBtAKBrAGvUdk9PffzqgvXs31Z6Okf8llXat4IK/YuB7QA/JiJ0BZaNIQS+7ndtAJjNesfCC8ktjshOafGLitsc4DsPCjj/7wweV0RNABHHTbE+ObkmoZBlE9RXU5v1gMFVJOQtWZRz3MrNCg/zq93tdo0+SJLqnCy7endY6z1k+3Z9HNSU5bA5e/Er8jE/4IbL0zWhZgWTZcISH5ZuJICUN72Ag4u7yL3poPv+zdl86UCAwEAAQ=="},
               	{"host": "perspectives6.networknotary.org:8080", "public_key": "MIHKMA0GCSqGSIb3DQEBAQUAA4G4ADCBtAKBrAGgQqPeMH0hYpJqSfsOPkJfZqQ731cYf/yvi54Zlux0S42aUu947T+d7GkH1SF25BAOK9suPfhPq7DKCvZ9MTOyNPlxpb6q82EgKV7LkqRfbBU6G5Xu8vN6Auif/gc4OYunCzru/ZKYM6Inp7tkl60/uEcsoHQtQMDguJEiuDuTFmkhOF6HsM4GAa2Wji612U0bB3hcjpJNQ0L3CWrWQNjpZAoS7ONaLk8IP9kCAwEAAQ=="},
               	{"host": "perspectives7.networknotary.org:8080", "public_key": "MIHKMA0GCSqGSIb3DQEBAQUAA4G4ADCBtAKBrAFndaQshFiJmW9FDgmGQ8SgVs/5F8e1LQAyTyt2iW9J1Kavu2hisFhIShU2rOkv0w3j9JanO+FbaA0vrqoWN0dnwRpc41JQtjzhNZgE0j78w4nu5lxwMiJ16OlZh7p6L/hoZsDGNYrtGIEm4w8NurncFlAQ5JZPmcbhKkXikVjYi/sNM5G2osRxAZjimscvDpLqWxzDjLv4VpbXXMGY1WsvQwca/ScQhTV/uu0CAwEAAQ=="},
               	{"host": "perspectives8.networknotary.org:8080", "public_key": "MIHKMA0GCSqGSIb3DQEBAQUAA4G4ADCBtAKBrAHrtkVD3O4XCkOdFwMqlEDVYTW6W82QQomSb9Pa/OGeRvbupk/d1iNNbBAs7B2Irg3Xk+OValBf29cUwXsYbpm3lEKGOqVhwas7YaHz4cnztkQJ5N+fW2eGe7iD1k1/wB7aPECPYVQgXOSpYcmg4999JGxjPE6LWmIu3KQfk1YtZBjGOI9Sa5wNhECvVoIMYGH1oG+oXkACpd6AgUJMfIOdG7BkwW9YFRKHPJkCAwEAAQ=="}
            ];
        }
        Perspectives.getQuorumAsInt = function() { return 7; }

        pref = function(key, value) {
            Perspectives.root_prefs[key] = value;
            //console.log(key + ": " + value);
        };

        Pers_pref             = null;
        Pers_results          = null;
        Pers_whitelist_dialog = null;
    }
</script>

<script type="text/javascript" src="../plugin/chrome/content/extlib/underscore-min.js"></script>
<script type="text/javascript" src="../plugin/chrome/content/extlib/spark-md5.min.js"></script>

<script type="text/javascript" src="../plugin/defaults/preferences/prefs.js"       ></script>
<script type="text/javascript" src="../plugin/chrome/content/about.js"             ></script>
<script type="text/javascript" src="../plugin/chrome/content/client_policy.js"     ></script>
<script type="text/javascript" src="../plugin/chrome/content/common.js"            ></script>
<script type="text/javascript" src="../plugin/chrome/content/generate_svg.js"      ></script>

<script type="text/javascript" src="../plugin/chrome/content/notify.js"            ></script>
<!--<script type="text/javascript" src="../plugin/chrome/content/preferences_dialog.js"></script>-->
<script type="text/javascript" src="../plugin/chrome/content/report.js"            ></script>
<!--<script type="text/javascript" src="../plugin/chrome/content/results_dialog.js"    ></script>-->
<script type="text/javascript" src="../plugin/chrome/content/statusbar.js"         ></script>
<!--<script type="text/javascript" src="../plugin/chrome/content/whitelist_dialog.js"  ></script>-->
<script type="text/javascript" src="../plugin/chrome/content/xml_notary_client.js" ></script>

<script type="text/javascript">
d_print_all = true;
other_cache = { "debug": "" }; // needed for common.js

var g_test_count = 0;
var g_pass_count = 0;
var g_fail_count = 0;

var MIN_SECS  = 60;
var HOUR_SECS = 60 * MIN_SECS;
var DAY_SECS  = 24 * HOUR_SECS;

/******* Helper Functions *******/
function clear() {
    var node = document.getElementById('results');
    node.innerHTML = "";
    g_test_count = 0;
    g_pass_count = 0;
    g_fail_count = 0;
}

function write_string(str) {
    write_string_to_element(str, 'p');
}

function write_string_to_element(str, elname) {
    var node = document.getElementById('results');
    var child = document.createElement(elname);
    child.innerHTML = str;
    node.appendChild(child);
}

function assert(test, case_name) {
    g_test_count++;
    if(test) {
        write_string_to_element('[' + g_test_count + '] <span style="color: green">passed</span> : ' + case_name, 'li');
        g_pass_count++;
    }
    else {
        write_string_to_element('[' + g_test_count + '] <b style="color: red">FAILED</b> : ' + case_name, 'li');
        g_fail_count++;
    }

    // if people are looking through the console to debug,
    // give them some help tracing the action.
    if(typeof window.console !== "undefined") {
        console.log("------- Finished test " + g_test_count + ": " + case_name);
    }
}

// convenience functions:
// add an easy way to denote that asserts are intended to verify test setup
// and test data, to make sure conditions are valid before we test.
// i.e. these asserts are not intended to directly verify functionality.
// this is purely a cosmetic difference to make it easier to think about
// what tests we are writing.
function assert_setup(test, case_name) {
    return assert(test, '<span style="color: grey">[test setup]</span> ' + case_name);
}

function assert_meta(test, case_name) {
    return assert_setup(test, case_name);
}

// make it easy to print error strings
function error(str) {
    write_string('<b style="color: red">ERROR:</b>' + str);
}

// placeholder function to note future tests we should implement.
// it's here so you can easily set up tests and enable/disable them
// by renaming the function they call.
function assert_fixme(test, case_name) {
    write_string_to_element('[-] <span style="color: grey">not implemented</span> : ' + case_name, 'li');
}

// add a horizontal bar to visuall separate some items or tests
function spacer(category_name) {
    write_string_to_element('------- <span style="color: grey">' + category_name + ':</span>', 'li');
}

// if you're lazy and want to print some text while debugging
function debug(obj) {

  if (obj === null || typeof obj === "undefined") {
    return;
  }

    if(obj instanceof Array) {
        deb_console("array contains:");
        for(var i = 0; i < obj.length; i++) {
            deb_console(obj[i]);
        }
    }
    else {
        deb_console(obj);
    }

    // strip out < so strings always appear on the page
    write_string_to_element('<span style="color: grey">DEBUG: ' + JSON.stringify(obj).replace(/</g, '&lt;') + '</span>', 'li');
}

function deb_console(obj) {
    if(typeof window.console !== "undefined") {
        console.log("DEBUG: " + obj);
    }
}

/******* Tests *******/

function meta_tests() {
    // make sure we can include and parse every object
    // so we'll be able to run tests on them.
    // if you add objects, add a test here

    write_string("Starting object creation tests");

    var objs =
        [ "Pers_about"
        , "Pers_client_policy"
        , "Pers_debug"
        , "Pers_util"
        , "Pers_keypress"
        , "Pers_gen"
        , "Perspectives"
        , "Pers_notify"
        , "Pers_pref"
        , "Pers_report"
        , "Pers_results"
        , "Pers_statusbar"
        , "Pers_whitelist_dialog"
        , "Pers_xml"
        ];

    for(var i = 0; i < objs.length; i++) {
        var key  = objs[i];
        var type = typeof window[key];
        assert(type === 'object', key + " is type '" + type + "'.");
    }

    write_string("Finished");
}

function hash_tests() {

  write_string("Starting hash tests");

  var known_md5_hash = "ffe5f73de2828ae744f3b126a7744fc3"; // verified independently with three external MD5 calculators
  var md5_test_string = "This is the Perspectives project browser extension MD5 test";
  var md5_hash = SparkMD5.hash(md5_test_string);
  assert((md5_hash === known_md5_hash), "MD5 hash of test string: " + known_md5_hash);

  write_string("Finished");
}

function client_sanity() {
    write_string("Starting client policy unit tests...");

    var key = "b1:7f:b1:15:25:4e:7b:fb:93:83:ac:5c:26:df:f7:00";
    var curtime = Pers_util.get_unix_time();
    var short_start = curtime - 1;
    var short_end = curtime;
    var short_result_list = [
        { "server": "test1:8080",
            "obs": [
                { "key": key,
                    "timestamps": [
                        { "start": short_start, "end": short_end  }
                    ] }
            ]
        }
    ];

    var day_first_seen = 4; // days ago
    var duration       = 2; // days
    var day_last_seen = day_first_seen - duration;
    var old_start = curtime - Pers_util.DAY2SEC(day_first_seen);
    var old_end = curtime - Pers_util.DAY2SEC(day_last_seen);

    var second_result_list = [
        { "server": "test1:8080",
            "obs": [
                { "key": key,
                    "timestamps": [
                        { "start": old_start, "end": old_end  }
                    ] }
            ]
        },
        { "server": "test2:8080",
            "obs": [
                { "key": key,
                    "timestamps": [
                        { "start": old_start, "end": old_end  }
                    ] }
            ]
        }
    ];

    assert_setup(short_start <= short_end, "Short keys start before they end.");
    assert_setup(old_start <= old_end, "Old keys start before they end.");

    var result_count = second_result_list.length;
    var smaller_quorum_size = 1;
    var equal_quorum_size = result_count;
    var bigger_quorum_size = 3;

    assert_setup(result_count === 2, "There are two observations in the results list.");
    assert_setup(smaller_quorum_size < result_count, "Smaller quorum size < result count");
    assert_setup(bigger_quorum_size > result_count, "Bigger quorum size > result count");
    assert_setup(bigger_quorum_size > equal_quorum_size &&
                equal_quorum_size > smaller_quorum_size &&
                smaller_quorum_size >= 1, "all quorum sizes are >= 1");

    spacer("weakly seen results");
    var weakly_seen0 = Pers_client_policy.key_weakly_seen_by_quorum(key, short_result_list, smaller_quorum_size, -10);
    assert(weakly_seen0 === false, "Negative Check lengths can't be weakly seen");

    var weak_check_time_limit = Pers_util.SEC2DAY(curtime + curtime);
    var weakly_seen1 = Pers_client_policy.key_weakly_seen_by_quorum(key, short_result_list, smaller_quorum_size, weak_check_time_limit);
    assert(weakly_seen1 === false, "Check lengths longer than time since the epoch can't be weakly seen");

    var weakly_seen2 = Pers_client_policy.key_weakly_seen_by_quorum(key, short_result_list, -1, 1);
    assert(weakly_seen2 === false, "Negative quorum sizes can't be weakly seen");

    var weakly_seen3 = Pers_client_policy.key_weakly_seen_by_quorum(key, short_result_list, 0, 1);
    assert(weakly_seen3 === false, "Quorum size 0 can't be weakly seen");

    var check_length0 = day_last_seen + 1; //days
    assert_setup(check_length0 >= 1, "check length >= 1");
    assert_setup(check_length0 >= day_last_seen  , "check length >= ending day of observation.");
    var weakly_seen_test = Pers_client_policy.key_weakly_seen_by_quorum(key, second_result_list, bigger_quorum_size, check_length0);
    assert(weakly_seen_test === false       , "Keys seen but by fewer than quorum_size notaries do not count as weakly seen.");

    var check_length1 = day_last_seen - 1; //days
    assert_setup(check_length1 >= 1, "check length >= 1");
    assert_setup(check_length1 < day_last_seen  , "check length < ending day of observation.");
    weakly_seen_test = Pers_client_policy.key_weakly_seen_by_quorum(key, second_result_list, equal_quorum_size, check_length1);
    assert(weakly_seen_test === false       , "Keys seen by quorum_size notaries but not in the past X days do not count as weakly seen.");

    var check_length2 = day_last_seen + 1; //days
    assert_setup(check_length2 >= 1, "check length >= 1");
    assert_setup(check_length2 >= day_last_seen  , "check length >= ending day of observation.");
    weakly_seen_test = Pers_client_policy.key_weakly_seen_by_quorum(key, second_result_list, equal_quorum_size, check_length2);
    assert(weakly_seen_test === true        , "Keys seen by quorum_size notaries AND in the past X days DO count as weakly seen.");

    var check_length3 = day_last_seen; //days
    assert_setup(check_length3 >= 1, "check length >= 1");
    assert_setup(check_length3 === day_last_seen , "check length === ending day of observation.");
    weakly_seen_test = Pers_client_policy.key_weakly_seen_by_quorum(key, second_result_list, equal_quorum_size, check_length3);
    assert(weakly_seen_test === true        , "Keys seen by quorum_size notaries exactly in the past X days DO count as weakly seen.");

    spacer("inconsistent results");
    var key2 = "b1:7f:b1:15:25:4e:7b:fb:93:83:ac:5c:26:df:f7:11";
    var third_result_list = [
        { "server": "test1:8080",
            "obs": [
                { "key": key,
                    "timestamps": [
                        { "start": old_start, "end": old_end  }
                    ] },
                { "key": key2,
                    "timestamps": [
                        { "start": old_start, "end": old_end  }
                    ] }
            ]
        }
    ];

    var check_length = 10;
    var regular_max = 8;
    var big_max = 12;
    var empty_result_list = [];

    assert_setup(big_max > check_length, "big_max is greater than check length");
    assert_setup(regular_max < check_length, "regular_max is less than check length");

    var is_inconsistent0 = Pers_client_policy.inconsistency_check(empty_result_list, regular_max, big_max);
    assert(is_inconsistent0 === false, "Empty result lists are not inconsistent.");

    var is_inconsistent1 = Pers_client_policy.inconsistency_check(third_result_list, big_max, check_length);
    assert(is_inconsistent1 === false, "Max timespan cannot be greater than check length.");

    assert_setup(third_result_list[0].obs.length > 1, "Result set has more than one observation.");
    var is_inconsistent2 = Pers_client_policy.inconsistency_check(third_result_list, regular_max, check_length);
    assert(is_inconsistent2 === true, "Results are marked inconsistent if there was no timespan longer than 'max_timespan' in the last 'check_length' days.");

    var valid_duration = duration - 1;
    assert_setup(valid_duration < check_length, "duration < check_length");
    var is_inconsistent3 = Pers_client_policy.inconsistency_check(third_result_list, valid_duration, check_length);
    assert(is_inconsistent3 === false, "Same results are *not* inconsistent if timespan is shortened. At least one timespan longer than max in the past check length days.");

    // hacky deep-copy of the array, so we don't modify the original data.
    // we're not very worried about speed, since this is a test.
    var single_result_list = JSON.parse(JSON.stringify(third_result_list));
    var len_before = single_result_list[0].obs.length;
    single_result_list[0].obs.splice(1,1);
    var len_after = single_result_list[0].obs.length;

    assert_setup(len_before === (len_after + 1), "observation removed from results");
    assert_setup(len_after === 1, "only a single observation in results");
    assert_setup(third_result_list[0].obs.length === len_before, "original data was not modified.");

    var is_inconsistent4 = Pers_client_policy.inconsistency_check(single_result_list, regular_max, check_length);
    assert(is_inconsistent4 === false, "False if there was no timespan longer than 'max_timespan' in the last 'check_length' days BUT only one key total in the replies.");

}

function nonrouted_ips() {
    write_string("Starting nonrouted ip unit tests...");

    // nonrouted means the address is private and unreachable by notaries.
    spacer("Reachable addresses");

    var names =
        [ "perspectives-project.org"
        , "github.com"
        , "test0.net"
        , "test1.net"
        , "test2.net"
        , "test3.net"
        , "test4.net"
        , "test5.net"
        , "test6.net"
        , "test7.net"
        , "test8.net"
        , "test9.net"
        , "100tests.net" // hosts that contain numbers should still work
        , "1000tests.net"
        , "test100tests.net"
        , "192168tests.net"
        ];

    for(var n = 0; n < names.length; n++) {
        var name = names[n];
        assert(Perspectives.is_nonrouted_ip(name) === false, name);
    }

    spacer("Unreachable by notaries");

    var ips =
        [ "127.0.0.1"
        , "169.254.15.59"
        , "10.0.0.0" // pick something in the beginning/middle/end of each RFC1918 private space
        , "10.0.0.1"
        , "10.255.254.254"
        , "172.16.0.0"
        , "172.16.1.1"
        , "172.31.254.254"
        , "192.168.0.0"
        , "192.168.10.21"
        , "192.168.254.254"
        ];

    for(var i = 0; i < ips.length; i++) {
        var ip = ips[i];
        assert(Perspectives.is_nonrouted_ip(ip) === true, ip);
    }

    write_string("Done!");
}

function quorum_basics() {
    write_string("Starting basic quorum tests...");

    var key1 = "b1:7f:b1:15:25:4e:7b:fb:93:83:ac:5c:26:df:f7:00";
    var key2 = "b2:7f:b1:15:25:4e:7b:fb:93:83:ac:5c:26:df:f7:00";
    var key3 = "b3:7f:b1:15:25:4e:7b:fb:93:83:ac:5c:26:df:f7:00";
    var cur_time       = 10000;
    var max_stale_sec  =   200;
    var key_beg_diff   =  1000;
    var key_beg_time   = cur_time - key_beg_diff;
    var key_end_time   = cur_time;

    var server_result_list = [
        { "server": "204.255.124.41:8080",
            "obs": [
                { "key": key1,
                    "timestamps": [
                        { "start": 0, "end": key_end_time  }
                    ] }
            ]
        },
        { "server": "128.2.185.85:8080",
            "obs": [
                { "key": key1,
                    "timestamps": [
                        { "start": key_beg_time, "end": key_end_time  }
                    ] }
            ]
        }
    ];

    var quorum_duration = 0;

    assert_setup(key_end_time > 0, "key_end_time > 0");
    assert_setup(key_end_time > key_beg_time, "key_end_time >  key_beg_time");

    quorum_duration = Pers_client_policy.get_quorum_duration(key1, server_result_list, 2, max_stale_sec, cur_time);
    assert(quorum_duration === cur_time - key_beg_time + 1  , "Requiring larger quorum gives a shorter duration");

    quorum_duration = Pers_client_policy.get_quorum_duration(key1, server_result_list, 1, max_stale_sec, cur_time);
    assert(quorum_duration === cur_time + 1                 , "Requiring smaller quorum gives a longer duration");
    assert(quorum_duration >   cur_time - max_stale_sec     , "Getting enough quorum voters passes");

    quorum_duration = Pers_client_policy.get_quorum_duration(key1, server_result_list, 10, max_stale_sec, cur_time);
    assert(quorum_duration === -1                           , "Getting fewer quorum voters than required fails");

    spacer('When observations end at the current time');
    quorum_duration = Pers_client_policy.get_quorum_duration(key1, server_result_list, 1, max_stale_sec, cur_time);
    assert(key_end_time    >   cur_time - max_stale_sec     , "The key is within the quorum time limit.");
    assert(quorum_duration >=  1                            , "Searching for an existing key within the time limit has a positive duration");
    // FIXME: assert fails
    // lambdor: shouldn't that be the crossing of oldest timestamp.end and (cur_time - max_stale_sec)?
    assert(quorum_duration === cur_time + max_stale_sec + 1 , "The duration is as long as the observation.start to observation.end (Expected " + (cur_time + max_stale_sec + 1) + ", got " + quorum_duration + ")");

    quorum_duration = Pers_client_policy.get_quorum_duration(key1, server_result_list, 1, max_stale_sec, cur_time + max_stale_sec + 1);
    assert(quorum_duration === -1                           , "Being over the quorum duration time limit fails");

    // run tests with keys that don't end exactly at the current time
    spacer('When observations *do not* end at the current time');
    cur_time += 100;

    assert(key_end_time > cur_time - max_stale_sec          , "Key is inside the quorum duration limit.");
    quorum_duration = Pers_client_policy.get_quorum_duration(key1, server_result_list, 1, max_stale_sec, cur_time);
    assert(quorum_duration >= 1                             , "2. Being at the edge of the quorum duration time limit passes");
    // FIXME: assert fails, see above
    assert(quorum_duration === cur_time + max_stale_sec + 1 , "2. The duration is as long as the observation.start to observation.end (i.e. it does NOT also count time that is white/a gap between it's end an the current time). (Expected " + (cur_time + max_stale_sec + 1) + ", got " + quorum_duration + ")");

    cur_time += 2 * max_stale_sec;
    assert(key_end_time    < cur_time - max_stale_sec       , "With changes, key is *outside* the quorum duration limit.");
    quorum_duration = Pers_client_policy.get_quorum_duration(key1, server_result_list, 1, max_stale_sec, cur_time + max_stale_sec + 1);
    assert(quorum_duration === -1                           , "2. Being over the quorum duration time limit fails");

    quorum_duration = Pers_client_policy.get_quorum_duration(key2, server_result_list, 1, max_stale_sec, cur_time);
    assert(quorum_duration === -1                           , "Looking for a key that has no results fails");

    var empty_result_list = [];
    quorum_duration = Pers_client_policy.get_quorum_duration(key1, empty_result_list, 1, max_stale_sec, cur_time);
    assert(quorum_duration === -1                           , "Passing an empty results list fails");

    spacer('Observations with gaps (duration is still counted correctly if there is a gap between keys)');

    max_stale_sec         =  600;
    cur_time              = 2000;
    // leave a gap between the end of the key and the current time
    var key1_duration     =  200;
    var end_time_1        = cur_time - 100;
    var beg_time_1        = end_time_1 - key1_duration;
    var key2_duration     =  400;
    var end_time_2        = beg_time_1 - 150;
    var orig_end_time_2   = end_time_2;
    var beg_time_2        = end_time_2 - key2_duration;
    var orig_beg_time_2   = beg_time_2;

    assert_setup(cur_time   >  end_time_1                 , "Gap setup: key1 ends before the current time"       );
    assert_setup(end_time_1 >  beg_time_1                 , "Gap setup: key1 begins before it ends"              );
    assert_setup(beg_time_1 >  end_time_2                 , "Gap setup: key2 ends before key1 begins"            );
    assert_setup(end_time_2 >  beg_time_2                 , "Gap setup: key2 begins before it ends"              );
    assert_setup(beg_time_2 >= 0                          , "Gap setup: all times are non-negative"              );
    assert_setup(end_time_1 >  cur_time - max_stale_sec   , "Gap setup: Target key1 ends inside the cutoff limit");
    assert_setup(end_time_1 - beg_time_1 === key1_duration, "Gap setup: key one lasts " + key1_duration + "."    );
    assert_setup(end_time_2 - beg_time_2 === key2_duration, "Gap setup: key two lasts " + key2_duration + "."    );

    var gap_result_list = [
        { "server": "204.255.124.41:8080",
            "obs": [
                { "key": key1,
                    "timestamps": [
                        { "start": beg_time_1, "end": end_time_1  }
                    ] }
            ]
        },
        { "server": "128.2.185.85:8080",
            "obs": [
                { "key": key2,
                    "timestamps": [
                        { "start": beg_time_2, "end": end_time_2  }
                    ] }
            ]
        }
    ];

    //(i.e. only as long as the bar, and only if inside cutoff)
    // FIXME: assert fails, see above
    var gap_quorum_duration1 = Pers_client_policy.get_quorum_duration(key1, gap_result_list, 1, max_stale_sec, cur_time);
    assert(gap_quorum_duration1 === end_time_1 - beg_time_1 + 1  , "Target key first: |curtime| .. |current key| .. |other key| {cutoff} (should be " + (end_time_1 - beg_time_1 + 1) + ", not " + (cur_time - beg_time_1 + 1) + ": got " + gap_quorum_duration1 + ").");

    // the 'weakly seen' property is relative to the current time,
    // so allow a check length going back to the end date of the observation.
    var weak_check_time_limit = Pers_util.SEC2DAY(Pers_util.get_unix_time() - end_time_2);
    var gap_weakly_seen1      = Pers_client_policy.key_weakly_seen_by_quorum(key1, gap_result_list, 1, weak_check_time_limit);
    assert(gap_weakly_seen1 === true                             , "key is 'weakly seen'");

    assert_setup(end_time_2 > cur_time - max_stale_sec                 , "Gap setup: New target key2 ends inside the cutoff limit");
    var gap_quorum_duration2 = Pers_client_policy.get_quorum_duration(key2, gap_result_list, 1, max_stale_sec, cur_time);
    // FIXME: assert fails, see above
    assert(gap_quorum_duration2 === end_time_2 - beg_time_2 + 1  , "Target key second: |curtime| .. |other key| .. |current key.. {cutoff} .. |(should be " + (end_time_2 - beg_time_2 + 1) + ", not " + (cur_time - beg_time_2 + 1) + ": got " + gap_quorum_duration2 + ").");

    var gap_weakly_seen2 = Pers_client_policy.key_weakly_seen_by_quorum(key2, gap_result_list, 1, weak_check_time_limit);
    assert(gap_weakly_seen2 === true                             , "key2 is 'weakly seen'");

    // if we had the same result set without the gap, the durations should be the same
    spacer("Gap and non-gap durations should be the same");
    end_time_2 = beg_time_1; // all other variables from above are the same.
    beg_time_2 = end_time_2 - key2_duration;

    assert_setup(cur_time   >   end_time_1                , "Nongap setup: key1 ends before the current time");
    assert_setup(end_time_1 >   beg_time_1                , "Nongap setup: key1 begins before it ends");
    assert_setup(beg_time_1 === end_time_2                , "Nongap setup: key2 ends *exactly when* key1 begins");
    assert_setup(end_time_2 >   beg_time_2                , "Nongap setup: key2 begins before it ends");
    assert_setup(beg_time_2 >=  0                         , "Nongap setup: all times are non-negative");
    assert_setup(end_time_1 >   cur_time - max_stale_sec  , "Nongap setup: Target key1 ends inside the cutoff limit");
    assert_setup(end_time_1 - beg_time_1 === key1_duration, "Nongap setup: key one lasts " + key1_duration + ".");
    assert_setup(end_time_2 - beg_time_2 === key2_duration, "Nongap setup: key two lasts " + key2_duration + ".");

    var non_gap_result_list = [
        { "server": "204.255.124.41:8080",
            "obs": [
                { "key": key1,
                    "timestamps": [
                        { "start": beg_time_1, "end": end_time_1  }
                    ] }
            ]
        },
        { "server": "128.2.185.85:8080",
            "obs": [
                { "key": key2,
                    "timestamps": [
                        { "start": beg_time_2, "end": end_time_2  }
                    ] }
            ]
        }
    ];

    var nongap_quorum_duration1 = Pers_client_policy.get_quorum_duration(key1, non_gap_result_list, 1, max_stale_sec, cur_time);
    // FIXME: assert fails, see above
    assert(nongap_quorum_duration1 === end_time_1 - beg_time_1 + 1, "Target key first: |curtime| .. |current key||other key| {cutoff} (should be " + (end_time_1 - beg_time_1 + 1) + ", not " + (cur_time - beg_time_1 + 1) + ": got " + nongap_quorum_duration1 + ").");
    // FIXME: assert fails, see above
    assert(nongap_quorum_duration1 === gap_quorum_duration1       , "Duration is the same with and without gaps.");

    // the 'weakly seen' property is relative to the current time,
    // so allow a check length going back to the end date of the observation.
    weak_check_time_limit = Pers_util.SEC2DAY(Pers_util.get_unix_time() - end_time_2);
    var nongap_weakly_seen1 = Pers_client_policy.key_weakly_seen_by_quorum(key1, non_gap_result_list, 1, weak_check_time_limit);
    assert(nongap_weakly_seen1 === true                           , "key is 'weakly seen'");
    // the important tests - that results with and without gaps are the same.
    assert(nongap_weakly_seen1 === gap_weakly_seen1               , "'weakly seen' result is the same with and without gaps.");
    assert_setup(end_time_2 > cur_time - max_stale_sec                  , "Nongap setup: New target key2 ends inside the cutoff limit");

    var nongap_quorum_duration2 = Pers_client_policy.get_quorum_duration(key2, non_gap_result_list, 1, max_stale_sec, cur_time);
    assert(nongap_quorum_duration2 === end_time_2 - beg_time_2 + 1, "Target key second: |curtime| .. |other key||current key.. {cutoff} .. |(should be " + (end_time_2 - beg_time_2 + 1) + ", not " + (cur_time - beg_time_2 + 1) + ": got " + nongap_quorum_duration2 + ").");
    assert(nongap_quorum_duration2 === gap_quorum_duration2       , "Duration is the same with and without gaps.");

    // the 'weakly seen' property is relative to the current time,
    // so allow a check length going back to the end date of the observation.
    var nongap_weakly_seen2 = Pers_client_policy.key_weakly_seen_by_quorum(key2, non_gap_result_list, 1, weak_check_time_limit);
    assert(nongap_weakly_seen2 === true                           , "key is 'weakly seen'");
    assert(nongap_weakly_seen2 === gap_weakly_seen2               , "'weakly seen' result is the same with and without gaps.");

    spacer("Further gap tests");
    end_time_2 = orig_end_time_2;
    beg_time_2 = orig_beg_time_2;
    max_stale_sec = 200;
    assert_setup(end_time_2 < cur_time - max_stale_sec, "Gap setup: After change, target key2 ends *outside* the cutoff limit");
    quorum_duration = Pers_client_policy.get_quorum_duration(key2, gap_result_list, 1, max_stale_sec, cur_time);
    assert(quorum_duration === -1               , "Results with gaps do not give a duration if they happen after the time cutoff.");

    var gap_result_list2 = [
        { "server": "204.255.124.41:8080",
            "obs": [
                { "key": key1,
                    "timestamps": [
                        { "start": beg_time_1, "end": end_time_1  }
                    ] }
            ]
        },
        { "server": "128.2.185.85:8080",
            "obs": [
                { "key": key1,
                    "timestamps": [
                        { "start": beg_time_2, "end": end_time_2  }
                    ] }
            ]
        }
    ];

    // currently this will calculate duration using the oldest matching key inside the
    // cutoff range.
    // TODO: should we use the longest or shortest one instead?
    quorum_duration = Pers_client_policy.get_quorum_duration(key1, gap_result_list2, 1, max_stale_sec, cur_time);
    // FIXME: assert fails, see above
    assert(quorum_duration === end_time_2 - beg_time_2 + 1, "Target key second: |curtime| .. |current key| .. |current key.. {cutoff} .. |(should be " + (end_time_2 - beg_time_2 + 1) + ", not " + (cur_time - beg_time_2 + 1) + ": got " + quorum_duration + ").");
    // testing against a result set without gaps doesn't make sense here;
    // the two observations would be joined together.

    //TODO: more gap tests with multiple matching results from multiple notaries

    spacer('Quorums for certificates with short durations');

    var short_start = 10;
    var short_end   = 11;
    var short_result_list = [
        { "server": "test1:8080",
            "obs": [
                { "key": key1,
                    "timestamps": [
                        { "start": short_start, "end": short_end  }
                    ] }
            ]
        }
    ];

    assert_setup(short_end >= short_start, "short key ends after it begins ");

    // place cur_time within the 'valid range' cutoff
    cur_time      =   1 * DAY_SECS;
    max_stale_sec = 200;
    quorum_duration = Pers_client_policy.get_quorum_duration(key1, short_result_list, 1, max_stale_sec, cur_time);
    assert(quorum_duration === -1              , "A one-second duration out of the valid time window is inconsistent (got " + quorum_duration + ").");

    // the 'weakly seen' property is relative to the current time,
    // so allow a check length going back to the end date of the observation.
    weak_check_time_limit = Pers_util.SEC2DAY(Pers_util.get_unix_time() - short_end);
    var weakly_seen = Pers_client_policy.key_weakly_seen_by_quorum(key1, short_result_list, 1, weak_check_time_limit);
    assert(weakly_seen === true                , "keys with one second duration count as 'weakly seen'");

    max_stale_sec = 3 * DAY_SECS;
    quorum_duration = Pers_client_policy.get_quorum_duration(key1,
            short_result_list, 1, max_stale_sec, cur_time);
    // FIXME: assert fails, see above
    assert(quorum_duration === 1               , "A one-second duration within the valid time window is one second (got " + quorum_duration + ").");

    cur_time += 1 * DAY_SECS;
    assert_setup(cur_time - max_stale_sec < short_end, "Current time for the next test is still within the valid window.");
    var quorum_duration2 = Pers_client_policy.get_quorum_duration(key1, short_result_list, 1, max_stale_sec, cur_time);
    // FIXME: assert fails, see above
    assert(quorum_duration === quorum_duration2, "Changing the curtime within the valid window doesn't change the duration of the cert observation (got " + quorum_duration2 + ").");

    spacer('Quorums with a small number of notaries');

    //TODO: write code to save and restore all preferences after each test,
    //so it doesn't matter which we alter.
    var pref_string_extra_notaries = "perspectives.additional_notary_list";
    var pref_string_use_def_notary = "perspectives.use_default_notary_list";
    var orig_thresh               = Perspectives.root_prefs.getIntPref ("perspectives.quorum_thresh");
    var orig_extra_notaries       = Perspectives.root_prefs.getCharPref(pref_string_extra_notaries  );
    var orig_use_default_notaries = Perspectives.root_prefs.getBoolPref(pref_string_use_def_notary  );

    var single_notary = "localhost:8080\n\
-----BEGIN PUBLIC KEY-----\n\
MIHKMA0GCSqGSIb3DQEBAQUAA4G4ADCBtAKBrAGXsegzE6E/6j4vgzi3NqGSn2dz\
W6gRxkuAL7PB8QmRqtG9ieSQjFB6cTYvkmp7x/LtHqlr9Fa6+/mT4Ma5oKU0RpgY\
MyfYnEk0iiNWG2fj4mRpTscHfcEJfKP13OGAYP1ZuHksTXSYsaKfIwiVKMLgQ/hA\
FHBSCs9X+bvVMgPOiEpxZXfaynOQ3TLGYtVywLRwW5yvlRq4E9z0rtvwR1bn1hVd\
JaJ2Lw7kRVMCAwEAAQ==\
-----END PUBLIC KEY-----";

    try {
        var small_quorum_thresh = 1;
        Perspectives.root_prefs.setIntPref ("perspectives.quorum_thresh", small_quorum_thresh);
        Perspectives.root_prefs.setBoolPref(pref_string_use_def_notary  , false              );
        Perspectives.root_prefs.setCharPref(pref_string_extra_notaries  , single_notary      );

        var qint = Perspectives.getQuorumAsInt();
        assert(qint >= 1, small_quorum_thresh + "% Quorum Threhold with 1 notary still returns a required quorum count >= 1 (got " + qint + ").");

        var unixtime = Pers_util.get_unix_time();
        max_stale_sec = 2 * DAY_SECS;

        var consistent = Pers_client_policy.check_current_consistency(key1, server_result_list, 0, max_stale_sec, unixtime);
        assert(consistent === false , "Quorum size 0 is not consistent.");

        var has_quorum = Pers_client_policy.has_quorum_at_time(key1, server_result_list, 0, null);
        assert(has_quorum === false , "Quorum size 0 is fails at any given time.");

        quorum_duration = Pers_client_policy.get_quorum_duration(key1, server_result_list, 0, max_stale_sec, unixtime);
        assert(quorum_duration === 0, "Quorum size 0 gives zero duration");

        var full_quorum_thresh = 100;
        Perspectives.root_prefs.setIntPref ("perspectives.quorum_thresh", full_quorum_thresh);
        Perspectives.root_prefs.setBoolPref(pref_string_use_def_notary  , true              );

        qint = Perspectives.getQuorumAsInt();
        // FIXME: assert fails
        assert(qint === Perspectives.getNotaryList().length, full_quorum_thresh + "% Quorum Threhold with many notaries returns a full required quorum count (got " + qint + ").");

    }
    finally {
        Perspectives.root_prefs.setIntPref ("perspectives.quorum_thresh", orig_thresh              );
        Perspectives.root_prefs.setCharPref(pref_string_extra_notaries  , orig_extra_notaries      );
        Perspectives.root_prefs.setBoolPref(pref_string_use_def_notary  , orig_use_default_notaries);
    }

    write_string("Finished");
}

// Test cases: we pass the quorum percentage, but the key is really old.
// Originally this was found because get_quorum_duration() was passing
// parameters to oldest_most_recent() in the wrong order,
// making certain valid keys show up as not trusted.
function quorum_oldkey() {
    var keybc = "bc:7f:b1:15:25:4e:7b:fb:93:83:ac:5c:26:df:f7:00"; //the key we're looking for
    var keybd = "bd:7f:b1:15:25:4e:7b:fb:93:83:ac:5c:26:df:f7:00";

    var cur_time            = 200 * DAY_SECS; //i.e. 200 days since epoch
    var max_stale_sec       =   2 * DAY_SECS;
    var q_required          =   1;
    var q_duration_required = 100 * DAY_SECS;
    var foundkey_start      = 100;

    // see testcase description inside assert() calls, below, for explanations
    // of array contents.
    var results_oldkey = [
        { "server": "128.2.185.85:8080",
            "obs": [
                {"key": keybc,
                    "timestamps": [
                        { "start": foundkey_start * DAY_SECS, "end": (foundkey_start + q_duration_required) * DAY_SECS }
                    ] }
            ]
        }
    ];

    var results_oldkey_notpushed = [
        { "server": "128.2.185.85:8080",
            "obs": [
                {"key": keybc,
                    "timestamps": [
                        { "start": foundkey_start * DAY_SECS, "end": (foundkey_start + q_duration_required) * DAY_SECS }
                    ] }
            ]
        },
        { "server": "204.255.124.41:8080",
            "obs": [
                { "key": keybd,
                    // start date of 10 is arbitrary
                    "timestamps": [
                        { "start": 10 * DAY_SECS, "end": foundkey_start * DAY_SECS }
                    ] }
            ]
        }
    ];

    // almost the same keys as above, except the unrelated key's time range ends 1 days earlier
    var results_oldkey_pushedout = [
        { "server": "204.255.124.41:8080",
            "obs": [
                { "key": keybd,
                    "timestamps": [
                        { "start": 10 * DAY_SECS, "end": (foundkey_start - 1 ) * DAY_SECS }
                    ] }
            ]
        },
        { "server": "128.2.185.85:8080",
            "obs": [
                {"key": keybc,
                    "timestamps": [
                        { "start": foundkey_start * DAY_SECS, "end": (foundkey_start + q_duration_required) * DAY_SECS }
                    ] }
            ]
        }
    ];

    write_string("Starting oldkey quorum tests...");
    var quorum_duration = 0;

    assert_setup(results_oldkey[0].obs[0].timestamps[0].end >=
     results_oldkey[0].obs[0].timestamps[0].start,
       "oldkey ends after it starts");

    assert_setup(results_oldkey_notpushed[0].obs[0].timestamps[0].end >=
       results_oldkey_notpushed[0].obs[0].timestamps[0].start,
       "results_oldkey_notpushed 0 ends after it starts");

    assert_setup(results_oldkey_notpushed[1].obs[0].timestamps[0].end >=
       results_oldkey_notpushed[1].obs[0].timestamps[0].start,
       "results_oldkey_notpushed 1 ends after it starts");

     assert_setup(results_oldkey_pushedout[0].obs[0].timestamps[0].end >=
       results_oldkey_pushedout[0].obs[0].timestamps[0].start,
       "results_oldkey_pushedout 0 ends after it starts");

    assert_setup(results_oldkey_pushedout[1].obs[0].timestamps[0].end >=
       results_oldkey_pushedout[1].obs[0].timestamps[0].start,
       "results_oldkey_pushedout 1 ends after it starts");

    quorum_duration = Pers_client_policy.get_quorum_duration(keybc, results_oldkey, q_required, max_stale_sec, cur_time);
    assert(quorum_duration >= q_duration_required    , "1) Old key within duration accepted");

    quorum_duration = Pers_client_policy.get_quorum_duration(keybc, results_oldkey, q_required, max_stale_sec, cur_time);
    assert(quorum_duration <= q_duration_required * 2, "2) Old key outside duration rejected");

    quorum_duration = Pers_client_policy.get_quorum_duration(keybc, results_oldkey_notpushed, q_required, max_stale_sec, cur_time);
    assert(quorum_duration > q_duration_required     , "3) Same as (1), but an unrelated key result ends on day target key begins");

    quorum_duration = Pers_client_policy.get_quorum_duration(keybc, results_oldkey_pushedout, q_required, max_stale_sec, cur_time);
    assert(quorum_duration > q_duration_required     , "4) Same as (1), but an unrelated key result ends the day before target key begins");

    write_string("Finished");
}

function notary_parsing() {
    var pref_string_extra_notaries = "perspectives.additional_notary_list";
    var pref_string_use_def_notary = "perspectives.use_default_notary_list";
    var orig_extra_notaries        = null;
    var orig_use_default_notaries  = null;

    write_string("Starting notary parsing tests.");

    // save preferences so we can restore state afterward
    orig_extra_notaries       = Perspectives.root_prefs.getCharPref(pref_string_extra_notaries);
    orig_use_default_notaries = Perspectives.root_prefs.getBoolPref(pref_string_use_def_notary);

    if(orig_extra_notaries === null || orig_use_default_notaries === null) {
        error("Could not read preferences from Perspectives plugin. Skipping notary parse tests.");
        g_test_count++;
        g_fail_count++;
        return;
    }

    // set preferences to known state so we can run our tests in a controlled env
    Perspectives.root_prefs.setCharPref(pref_string_extra_notaries, ""  );
    Perspectives.root_prefs.setBoolPref(pref_string_use_def_notary, true);

    var notaries     = "";
    var count_before = 0;

    notaries = Perspectives.getNotaryList();
    assert(notaries.length > 0, "Default notary list gets us > 0 notaries (we have " + notaries.length + ")");

    var nonsense_notary = "aaaaaaaa";
    // clear the extra notaries list to be sure what we're dealing with
    Perspectives.root_prefs.setCharPref(pref_string_extra_notaries, "");
    count_before = Perspectives.getNotaryList().length;
    Perspectives.root_prefs.setCharPref(pref_string_extra_notaries, nonsense_notary);
    notaries = Perspectives.getNotaryList();
    assert(notaries.length === count_before, "Trying to save a garbled notary string doesn't work.");

    // TODO bad method of declaration?
    // We need newlines after the server name and 'BEGIN PUBLIC KEY' lines
    // for the string to parse properly
    var test_notary_one = "testnotaryone.nowhere.org:8080\n\
-----BEGIN PUBLIC KEY-----\n\
MIHKMA0GCSqGSIb3DQEBAQUAA4G4ADCBtAKBrAGXsegzE6E/6j4vgzi3NqGSn2dz\
W6gRxkuAL7PB8QmRqtG9ieSQjFB6cTYvkmp7x/LtHqlr9Fa6+/mT4Ma5oKU0RpgY\
MyfYnEk0iiNWG2fj4mRpTscHfcEJfKP13OGAYP1ZuHksTXSYsaKfIwiVKMLgQ/hA\
FHBSCs9X+bvVMgPOiEpxZXfaynOQ3TLGYtVywLRwW5yvlRq4E9z0rtvwR1bn1hVd\
JaJ2Lw7kRVMCAwEAAQ==\
-----END PUBLIC KEY-----\n"; // end with a newline so we can concatenate

        var test_notary_two = "testnotarytwo.nowhere.org:8080\n\
-----BEGIN PUBLIC KEY-----\n\
MIHKMA0GCSqGSIb3DQEBAQUAA4G4ADCBtAKBrAGXsegzE6E/6j4vgzi3NqGSn2dz\
W6gRxkuAL7PB8QmRqtG9ieSQjFB6cTYvkmp7x/LtHqlr9Fa6+/mT4Ma5oKU0RpgY\
MyfYnEk0iiNWG2fj4mRpTscHfcEJfKP13OGAYP1ZuHksTXSYsaKfIwiVKMLgQ/hA\
FHBSCs9X+bvVMgPOiEpxZXfaynOQ3TLGYtVywLRwW5yvlRq4E9z0rtvwR1bn1hVd\
JaJ2Lw7kRVMCAwEAAQ==\
-----END PUBLIC KEY-----\n";

    var single_notary = Pers_util.loadNotaryListFromString(test_notary_one);
    assert(single_notary.length === 1, "Trying to parse a single notary works.");

    assert_setup(test_notary_one !== test_notary_two, "test notaries are distinct.");
    var distinct_notaries = Pers_util.loadNotaryListFromString(test_notary_one + test_notary_two);
    assert(distinct_notaries.length > 1, "Trying to parse multiple distinct notaries works.");

    var duplicate_notaries = Pers_util.loadNotaryListFromString(test_notary_one + test_notary_one + test_notary_one);
    assert(duplicate_notaries.length === 1, "Trying to parse a duplicate notary is ignored.");

    var sparse_notary = "perspectivesFAKETEST.networknotary.org:8080\n\n\n\n\
-----BEGIN PUBLIC KEY-----\n\n\n\n\n\
MIHKMA0GCSqGSIb3DQEBAQUAA4G4ADCBtAKBrAGXsegzE6E/6j4vgzi3NqGSn2dz\n\n\n\n\
W6gRxkuAL7PB8QmRqtG9ieSQjFB6cTYvkmp7x/LtHqlr9Fa6+/mT4Ma5oKU0RpgY\n\n\n\n\
MyfYnEk0iiNWG2fj4mRpTscHfcEJfKP13OGAYP1ZuHksTXSYsaKfIwiVKMLgQ/hA\n\n\n\n\
FHBSCs9X+bvVMgPOiEpxZXfaynOQ3TLGYtVywLRwW5yvlRq4E9z0rtvwR1bn1hVd\n\n\n\n\
JaJ2Lw7kRVMCAwEAAQ==\n\n\n\n\
-----END PUBLIC KEY-----\n\n\n\n";

    Perspectives.root_prefs.setCharPref(pref_string_extra_notaries, "");
    count_before = Perspectives.getNotaryList().length;
    Perspectives.root_prefs.setCharPref(pref_string_extra_notaries, sparse_notary);
    notaries = Perspectives.getNotaryList();
    assert(notaries.length === count_before + 1, "Trying to add a notary with many blank lines works.");

    // restore state once we're finished all of the tests
    Perspectives.root_prefs.setCharPref(pref_string_extra_notaries, orig_extra_notaries      );
    Perspectives.root_prefs.setBoolPref(pref_string_use_def_notary, orig_use_default_notaries);

    write_string("Finished");
}

function notary_replies() {
    write_string("Starting notary reply tests");

    //TODO: overwrite, or ignore?
    assert_fixme(false, "Don't accept multiple responses from the same server");
    //we can test this by temporarily allowing duplicates and sending out two responses.
    //but it's even better if we can just do it in code.

    // fake AJAX requests
    var oldXMLHttpRequest = XMLHttpRequest;
    window.timeouts = 0;
    window.timeout_host = "";
    window.XMLHttpRequest = function() {
        this.url;
        this.readyState;
        this.status;
        this.responseText;
        this.responseXML = window.responseXML;

        this.open = function(_0, url, _2) {
            this.url = url;
        }
        this.send = function(_0) {
            var host = this.url.replace('http://', '').substr(0, this.url.indexOf('?') - "http://".length);
            if(window.timeouts <= 0 && host !== window.timeout_host) {
                setTimeout(_.bind(function() { this.onreadystatechange(null); }, this), 0);
            }
            else {
                window.timeouts -= 1;
            }
        }
    };

    var response_valid =
        '<notary_reply sig="base64string" sig_type="rsa-md5" version="1">' +
        '	<key fp="01:23:45:67:89:ab:cd:ef:01:23:45:67:89:ab:cd:ef" type="ssl">' +
        '		<timestamp start=  "0" end="100" />' +
        '		<timestamp start="200" end="300" />' +
        '		<timestamp start="400" end="500" />' +
        '	</key>' +
        '</notary_reply>';
    var response_invalid =
        '<notary_reply sig="base64string" sig_type="rsa-md5" version="1">' +
        '	<key fp="01:23:45:67:89:ab:cd:ef:01:23:45:67:89:ab:cd:ef" type="ssl">' +
        '		<timestamp end=  "0" start="100" />' +
        '		<timestamp end="200" start="300" />' +
        '		<timestamp end="400" start="500" />' +
        '	</key>' +
        '</notary_reply>';
    var responseXML_valid   = (new DOMParser()).parseFromString(response_valid  , "text/xml");
    var responseXML_invalid = (new DOMParser()).parseFromString(response_invalid, "text/xml");

    XMLHttpRequest.prototype.readyState   =   4;
    XMLHttpRequest.prototype.status       = 200;
    XMLHttpRequest.prototype.responseText = "fake response text";

    var uri    = {host: "www.example.com", port: "42"}
    var notary_valid   = {host: "notary_valid.fake"  , public_key: "true" }
    var notary_invalid = {host: "notary_invalid.fake", public_key: "false"}
    var signature_verifier = {
        verifyData : function(bin_result, signature, public_key) {
            return (public_key === "true");
        }
    };

    window.timeouts = 0;
    var timeout_ms = 100;
    Perspectives.root_prefs.setIntPref("extensions.perspectives.query_timeout_ms", timeout_ms);
    var query_retries = 3;
    Perspectives.root_prefs.setIntPref("extensions.perspectives.query_retries", query_retries);

    var setTimeoutAux = function(func) { setTimeout(func, timeout_ms * (query_retries + 1) + 10); }

    write_string("querySingleNotary()");

    window.responseXML = responseXML_valid;
    setTimeoutAux( function() {
        Perspectives.querySingleNotary(uri, notary_valid, function(notary_host, new_server_result) {
            assert( new_server_result.is_valid, "valid public keys and timestamps result in is_valid=true")
        }, signature_verifier);
    setTimeoutAux( function() {
        Perspectives.querySingleNotary(uri, notary_invalid, function(notary_host, new_server_result) {
            assert( !new_server_result.is_valid, "invalid public keys result in is_valid=false")
        }, signature_verifier);
    setTimeoutAux( function() {
        window.responseXML = responseXML_invalid;
        Perspectives.querySingleNotary(uri, notary_valid, function(notary_host, new_server_result) {
            assert( !new_server_result.is_valid, "invalid timestamps result in is_valid=false")
        }, signature_verifier);
    setTimeoutAux( function() {
        Perspectives.querySingleNotary(uri, notary_invalid, function(notary_host, new_server_result) {
            assert( !new_server_result.is_valid, "invalid public keys and invalid timestamps result in is_valid=false")
        }, signature_verifier);
    setTimeoutAux( function() {

    write_string("queryNotaries() with one notary");

    var cert_match   = {md5Fingerprint: "01:23:45:67:89:ab:cd:ef:01:23:45:67:89:ab:cd:ef"};
    var cert_nomatch = {md5Fingerprint: "00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00"};

    window.responseXML = responseXML_valid;
    Pers_util.get_unix_time = function() { return 600; }
    var required_duration = Perspectives.root_prefs.getIntPref("perspectives.required_duration");
    var q_required = 1;

    setTimeoutAux( function() {
        window.timeouts = 0;
        var publish_cert = Perspectives.queryNotaries(uri, [notary_valid], function(server_result_list) {
                assert(server_result_list[0].obs.length > 0, "single notary: cert + notary result => result (and shortcircuited)");
            }, signature_verifier);
        publish_cert(cert_match, q_required, required_duration);
    setTimeoutAux( function() {
        window.timeouts = 1;
        var publish_cert = Perspectives.queryNotaries(uri, [notary_valid], function(server_result_list) {
                assert(server_result_list[0].obs.length > 0, "single notary: cert + 1 timeout => result (and shortcircuited)");
            }, signature_verifier);
        publish_cert(cert_match, q_required, required_duration);
    setTimeoutAux( function() {
        window.timeouts = 2;
        var publish_cert = Perspectives.queryNotaries(uri, [notary_valid], function(server_result_list) {
                assert(server_result_list[0].obs.length > 0, "single notary: cert + 2 timeouts => result (and shortcircuited)");
            }, signature_verifier);
        publish_cert(cert_match, q_required, required_duration);
    setTimeoutAux( function() {
        window.timeouts = query_retries;
        var publish_cert = Perspectives.queryNotaries(uri, [notary_valid], function(server_result_list) {
                assert(server_result_list[0].obs.length === 0, "single notary: cert + no response => empty result");
            }, signature_verifier);
        publish_cert(cert_match, q_required, required_duration);
    setTimeoutAux( function() {
        window.timeouts = 0;
        var publish_cert = Perspectives.queryNotaries(uri, [notary_valid], function(server_result_list) {
                assert(server_result_list[0].obs.length > 0, "single notary: no cert + notary result => result");
            }, signature_verifier);
    setTimeoutAux( function() {
        window.timeouts = 1;
        var publish_cert = Perspectives.queryNotaries(uri, [notary_valid], function(server_result_list) {
                assert(server_result_list[0].obs.length > 0, "single notary: no cert + 1 timeout => result");
            }, signature_verifier);
    setTimeoutAux( function() {
        window.timeouts = 2;
        var publish_cert = Perspectives.queryNotaries(uri, [notary_valid], function(server_result_list) {
                assert(server_result_list[0].obs.length > 0, "single notary: no cert + 2 timeouts => result");
            }, signature_verifier);
    setTimeoutAux( function() {
        window.timeouts = query_retries;
        var publish_cert = Perspectives.queryNotaries(uri, [notary_valid], function(server_result_list) {
                assert(server_result_list[0].obs.length === 0, "single notary: no cert + no response => empty result");
            }, signature_verifier);
    setTimeoutAux( function() {

    write_string("queryNotaries() with multiple notaries requiring only 50% quorum and thus shortcurcuit");

    var notaries = [{host: "notary1", public_key: "true" }, {host: "notary2", public_key: "true" }, {host: "notary3", public_key: "true" }];

    var q_required50 = Math.ceil( notaries.length / 2 );

    setTimeoutAux( function() {
        window.timeouts = 0;
        var publish_cert = Perspectives.queryNotaries(uri, notaries, function(server_result_list) {
            assert(_.filter(server_result_list, function(server_result) {
                return server_result.obs.length > 0;
            }).length === q_required50, "multiple notaries 50%: cert + notary results no timeout => shortcircuit some results (n=" + q_required50 + ")" );
        }, signature_verifier);
        publish_cert(cert_match, q_required50, required_duration);
    setTimeoutAux( function() {
        window.timeouts = 1 * notaries.length;
        var publish_cert = Perspectives.queryNotaries(uri, notaries, function(server_result_list) {
            assert(_.filter(server_result_list, function(server_result) {
                return server_result.obs.length > 0;
            }).length === q_required50, "multiple notaries 50%: cert + 1 timeout per notary => shortcircuit some results (n=" + q_required50 + ")" );
        }, signature_verifier);
        publish_cert(cert_match, q_required50, required_duration);
    setTimeoutAux( function() {
        window.timeouts = 2 * notaries.length;
        var publish_cert = Perspectives.queryNotaries(uri, notaries, function(server_result_list) {
            assert(_.filter(server_result_list, function(server_result) {
                return server_result.obs.length > 0;
            }).length === q_required50, "multiple notaries 50%: cert + 2 timeouts per notary => shortcircuit some results (n=" + q_required50 + ")" );
        }, signature_verifier);
        publish_cert(cert_match, q_required50, required_duration);
    setTimeoutAux( function() {
        window.timeouts = query_retries * notaries.length;
        var publish_cert = Perspectives.queryNotaries(uri, notaries, function(server_result_list) {
            assert(_.all(server_result_list, function(server_result) {
                return server_result.obs.length === 0;
            }), "multiple notaries 50%: cert + all timeouts => empty result" );
        }, signature_verifier);
        publish_cert(cert_match, q_required50, required_duration);
    setTimeoutAux( function() {

    write_string("queryNotaries() with multiple notaries requiring 100% quorum");
    var q_required100 = notaries.length;

    setTimeoutAux( function() {
        window.timeouts = 0;
        var publish_cert = Perspectives.queryNotaries(uri, notaries, function(server_result_list) {
            assert(_.all(server_result_list, function(server_result) {
                return server_result.obs.length > 0;
            }), "multiple notaries 100%: cert + notary results => all results" );
        }, signature_verifier);
        publish_cert(cert_match, q_required100, required_duration);
    setTimeoutAux( function() {
        window.timeouts = 1 * notaries.length;
        var publish_cert = Perspectives.queryNotaries(uri, notaries, function(server_result_list) {
            assert(_.all(server_result_list, function(server_result) {
                return server_result.obs.length > 0;
            }), "multiple notaries 100%: cert + 1 timeout per notary => all results" );
        }, signature_verifier);
        publish_cert(cert_match, q_required100, required_duration);
    setTimeoutAux( function() {
        window.timeouts = 2 * notaries.length;
        var publish_cert = Perspectives.queryNotaries(uri, notaries, function(server_result_list) {
            assert(_.all(server_result_list, function(server_result) {
                return server_result.obs.length > 0;
            }), "multiple notaries 100%: cert + 2 timeouts per notary => all results" );
        }, signature_verifier);
        publish_cert(cert_match, q_required100, required_duration);
    setTimeoutAux( function() {
        window.timeouts = query_retries * notaries.length;
        var publish_cert = Perspectives.queryNotaries(uri, notaries, function(server_result_list) {
            assert(_.all(server_result_list, function(server_result) {
                return server_result.obs.length === 0;
            }), "multiple notaries 100%: cert + all timeouts => empty result" );
        }, signature_verifier);
        publish_cert(cert_match, q_required100, required_duration);
    setTimeoutAux( function() {
        window.timeouts = 0;
        window.timeout_host = notaries[0].host;
        var publish_cert = Perspectives.queryNotaries(uri, notaries, function(server_result_list) {
            assert(_.filter(server_result_list, function(server_result) {
                return server_result.obs.length > 0;
            }).length === (notaries.length - 1), "multiple notaries 100%: cert + no answer from 1. notary => some results" );
        }, signature_verifier);
        publish_cert(cert_match, q_required100, required_duration);
    setTimeoutAux( function() {
        write_string("Finished");
    });
    });
    });
    });
    });
    });
    });
    });
    });
    });
    });
    });
    });
    });
    });
    });
    });
    });
    });
    });
    });
    });
    });
    });
    }); // :D ... we may need an async library
}

function run_tests() {
    // check if we are running with chrome privileges or from within browser
    if(typeof Components.classes !== "undefined") {
        // print debug info to console by default
        Pers_debug.d_print_flags["error"] = true;

        try {
            Perspectives.init_data();

            clear();
            meta_tests();
            hash_tests();
            client_sanity();
            nonrouted_ips();
            quorum_basics();
            quorum_oldkey();
            notary_parsing();
            notary_replies();

            write_string("Finished: " + g_pass_count + "/" + g_test_count + " successes, "
                    + g_fail_count + " failures. ");
            if(g_test_count !== g_pass_count + g_fail_count) {
                error("Count totals did not match!");
            }
        } catch(e) {
            alert(e);
            error("tests did not finish: '" + e + "'.");
        }
    } else {
        error("You are probably running the test from browser context, but you need to run it from chrome context. Use 'make test' to to build and install the Perspectives extension and open chrome://perspectives/content/test/test.html");

        try {
            //Perspectives.init_data();

//            clear();
//            meta_tests();
//            client_sanity();
//            //nonrouted_ips();
//            quorum_basics();
//            quorum_oldkey();
//            //notary_parsing();
            notary_replies();

            write_string("Finished: " + g_pass_count + "/" + g_test_count + " successes, "
                    + g_fail_count + " failures. ");
            if(g_test_count !== g_pass_count + g_fail_count) {
                error("Count totals did not match!");
            }
        } catch(e) {
            alert(e);
            error("tests did not finish: '" + e + "'.");
        }
    }
}
</script>
</head>

<body>
    <img src="../img/default.png" title="Perspectives Logo"/>
    <input type="button" value="Run Tests" onclick="run_tests();">

    <p>Run with firebug or the web console to see detailed test output if something fails.</p>

    <h2>Results: </h2>
    <div id="results"></div>
</body>
</html>
